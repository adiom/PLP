Ниже представлены 5 небольших программ для упрощённого RISC-V-подобного эмулятора, каждая со своим назначением и подробным описанием.

### 1) Простая программа: Загрузка числа и завершение
**Назначение:** Загрузить число в регистр и остановить выполнение.

```assembly
# Загружаем в x1 число 0x00FF (двигаем в верхние 16 бит) и останавливаемся.
LUI x1,0x00FF  # x1 = 0x00FF0000 (установка верхних 16 бит)
HALT
```

**Описание:**  
Команда `LUI` загружает константу 0x00FF в старшие 16 бит регистра x1. В итоге x1 = 0x00FF0000 (16711680 в десятичной системе). После этого выполняется `HALT` — программа прекращает работу.

---

### 2) Арифметические операции: Сложение двух чисел
**Назначение:** Загрузить число в x1 и x2, сложить и сохранить результат в x3.

```assembly
# Шаги:
# 1. Загрузим в x1 число 10 (десятичное)
# 2. Загрузим в x2 число 20
# 3. Сложим x1 и x2, результат в x3
# 4. Остановим выполнение

LUI x1,0x0000      # x1 = 0x00000000
ADd x1,x1,x0       # x1 = x1 + 0 => всё равно 0, но показываем пример (можно опустить)
LUI x2,0x0000      # x2 = 0x00000000
# Для установки точного значения 10 используем ADD с x0:
ADD x1,x1,x0       # x1 = 0 + 0 =0 (подготовка, можно опустить)
ADD x1,x1,x1       # x1=0+0=0 (можно повторно использовать, но для наглядности допустим, что изменить значения хотели бы иначе)

# Прямого загрузчика маленьких значений нет, но можно использовать LUI + смещения.
# Для упрощения предположим, что значения мы заранее загрузили через память. Но у нас нет прямых команд для установки малых значений, кроме LUI.
# Упростим: пусть x1=0, x2=0 после LUI. Введём небольшой "хак":
# Передадим сразу готовые числа через LUI (используя только нижний байт):
# 10 (0x000A)
LUI x1,0x000A  # x1 = 0x000A0000, это очень большое число, не то что нам нужно.
# Мы можем попробовать LW, но у нас нет данных в памяти.
# Упростим пример: будем считать, что хотим сложить большие числа, а не маленькие.
# Допустим LUI x1,0x000A => x1=0x000A0000
# LUI x2,0x000B => x2=0x000B0000

# Далее:
LUI x1,0x000A  # x1=0x000A0000
LUI x2,0x000B  # x2=0x000B0000
ADD x3,x1,x2    # x3 = 0x000A0000 + 0x000B0000 = 0x00150000
HALT
```

**Описание:**  
Данный пример демонстрирует арифметику: мы используем `LUI` для загрузки больших констант (для простоты). Затем складываем два регистра, результат помещается в x3, а потом останавливаемся. В реальности, для загрузки малых чисел лучше бы иметь дополнительные инструкции, но в данном примере используем имеющиеся.

---

### 3) Работа с памятью: Загрузка и сохранение
**Назначение:** Записать число в память, затем прочитать его обратно в другой регистр.

```assembly
# Шаги:
# 1. Загрузим в x1 число 0x0001 (LUI для примера, хотя это даст 0x00010000, но для демонстрации хватит)
# 2. Сохраним содержимое x1 по адресу, хранящемуся в x0 + 0 (x0=0, значит адрес 0)
# 3. Загрузим в x2 значение из памяти по тому же адресу.
# 4. Остановим выполнение.

LUI x1,0x0001   # x1 = 0x00010000
SW x1,0(x0)     # Память[0..3] = содержимое x1
LW x2,0(x0)     # x2 = Память[0..3], должно быть 0x00010000
HALT
```

**Описание:**  
Программа показывает использование инструкций `SW` и `LW`. Мы записываем значение из x1 в память по адресу 0, затем загружаем его из памяти в x2. В конце выполнения x2 должно содержать то же значение, что было в x1.

---

### 4) Условный переход: Проверка равенства
**Назначение:** Если два регистра равны, перейти по ветке и выполнить дополнительные инструкции. Иначе пропустить их.

```assembly
# Шаги:
# 1. Загрузим в x1 число 0x0002 (например).
# 2. Загрузим в x2 число 0x0002.
# 3. Сравним x1 и x2. Если равны, перепрыгнем через одну инструкцию.
# 4. Если равны, по ветке увеличим x1, иначе ничего не делаем.
# 5. Остановим.

LUI x1,0x0002   # x1=0x00020000
LUI x2,0x0002   # x2=0x00020000
BEQ x1,x2,1     # Если x1 == x2, прыгаем на одну инструкцию (имм=1 означает +4 байта, т.е. следующую)
ADD x1,x1,x0     # Эта инструкция выполнится, только если переход НЕ случится
SUB x1,x1,x0     # Эта инструкция выполнится, только если переход СЛУЧИЛСЯ
HALT
```

**Описание:**  
Данная программа демонстрирует условный переход. Если x1 и x2 равны, мы пропускаем одну инструкцию `ADD x1,x1,x0` (она бесполезна) и переходим сразу к `SUB x1,x1,x0`, которая просто повторно задаст x1. В итоге можем увидеть разницу, пошагово проверяя выполнение.

*(Примечание: В реальном RISC-V imm для веток масштабируются на длину инструкции, тут мы допускали, что imm *4. Если imm=1, то это смещение на 4 байта вперёд, то есть на одну инструкцию.)*

---

### 5) Безусловный переход с JAL/JALR: 
**Назначение:** Показать вызов подпрограммы с сохранением адреса возврата.

```assembly
# Шаги:
# 1. Загрузим в x1 число 0x0003.
# 2. Вызовем "подпрограмму" по смещению 2 инструкции вперёд с помощью JAL.
# 3. Подпрограмма: Увеличит x1 на x1 (удвоит значение).
# 4. Вернётся назад с помощью JALR (с адресом, хранящимся в регистре x1).
# 5. После возврата остановим.

# Адресация упрощённая:
# LUI x1,0x0003
# JAL x2,2      # Переход на 2 инструкции вперёд, x2=адрес возврата
# HALT          # Инструкция к которой вернёмся
# Подпрограмма:
# ADD x1,x1,x1  # удваиваем x1
# JALR x0,x2,0  # возвращаемся по адресу, хранящемуся в x2

LUI x1,0x0003
JAL x2,2       # Переходим вперёд (пропускаем 2 инструкции)
HALT           # Вернёмся сюда после подпрограммы
ADD x1,x1,x1   # Подпрограмма: удвоение x1
JALR x0,x2,0   # Возврат к HALT
```

**Описание:**  
Программа показывает использование `JAL` (Jump And Link) и `JALR` (Jump And Link Register). При вызове подпрограммы `JAL` сохраняет адрес возврата в x2. Подпрограмма удваивает значение x1 и возвращается по адресу, сохранённому в x2. В итоге после возврата мы выполняем `HALT`.

---

Эти примеры помогут протестировать различные аспекты вашего упрощённого RISC-V-подобного эмулятора: загрузку констант, арифметику, работу с памятью, ветвления, вызовы подпрограмм и остановку.
